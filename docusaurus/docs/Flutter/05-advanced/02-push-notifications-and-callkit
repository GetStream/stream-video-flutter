---
id: adding_push_notifications_and_callkit
sidebar_position: 2
title: Push Notifications and CallKit
---

Adding Push Notifications And CallKit To Your Application

### Introduction

This guide details how to add push notifications and an end-to-end call flow to your app.

Push notifications are a core part of the experience for a video app. They can be simple reminders of calls or
trigger a larger end-to-end flow in which an immersive calling experience is presented.

Stream Video sends push notification to members that have at least one registered device.

To receive push notifications from Stream Video, you'll need to:

1. Configure your push notification provider on the Stream Dashboard.
2. Add the client-side integration. For Flutter this guide demonstrates using Firebase Cloud Messaging (FCM) for Android and Apple Push Notification Service (APNS) for iOS devices.

### Integrating Firebase for Android

#### Step 1 - Get the Firebase Credentials

These credentials are the [private key file](https://firebase.google.com/docs/admin/setup#:~:text=To%20generate%20a%20private%20key%20file%20for%20your%20service%20account%3A) for your service account, in Firebase console.

To generate a private key file for your service account in the Firebase console:

- Open Settings > Service Accounts.

- Click **Generate New Private Key**, then confirm by clicking **Generate Key**.

- Securely store the JSON file containing the key.

This JSON file contains the credentials that need to be uploaded to Streamâ€™s server, as explained in the next step.

#### Step 2 - Upload the Firebase Credentials to Stream

You now need to upload your Firebase credentials using the Stream dashboard.

- Go the the dashboard of your video project at the [Stream website](https://getstream.io).

- Open the **Push Notifications** tab under **Video & Audio**.

- Select **New Configuration** and select **Firebase**.

- Add a name for your push provider in the **Name** field and add your previously generated Firebase Credentials in the **Credentials JSON** field.

- Click **Create** and your push provider should be ready.

#### Step 3 - Add dependencies to your app

To integrate push notifications in your Flutter app, you need to use the package [`firebase_messaging`](https://pub.dev/packages/firebase_messaging).

Follow the [Flutter Firebase documentation](https://firebase.flutter.dev/docs/messaging/overview/) to set up the plugin for Android and iOS.
Additional setup and instructions can be found [here](https://firebase.google.com/docs/cloud-messaging/flutter/client). Be sure to read this documentation to understand Firebase messaging functionality.

Once that's done, FCM should be able to send push notifications to your devices.

#### Step 4 - Add code to listen to push notifications

- Add the following code in your `main.dart` as global functions to listen to background notifications:

```dart
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp();
  await AppRepository.initStreamVideo(); // TODO(Deven): Replace this line with a good way to initialise the client and push notification manager
  await _handleRemoteMessage(message);
}

Future<void> _handleRemoteMessage(RemoteMessage message) async {
  await StreamVideo.instance.handlePushNotification(message.data);
}
```

- The following changes are for the root widget of your app. First, add the `WidgetsBindingObserver` mixin to your widget state.
Then add the `didChangeAppLifecycleState()` method to consume any incoming calls when the app is resumed.

```dart
class _StreamDemoState extends State<StreamDemoApp> with WidgetsBindingObserver {

      // ...

      @override
      void didChangeAppLifecycleState(AppLifecycleState state) {
        super.didChangeAppLifecycleState(state);
        switch (state) {
          case AppLifecycleState.resumed:
            _consumeIncomingCall();
            break;
          case AppLifecycleState.inactive:
            // widget is inactive
            break;
          case AppLifecycleState.paused:
            // widget is paused
            break;
          case AppLifecycleState.detached:
            // widget is detached
            break;
        }
      }
}
```

- In the `initState()` method of the widget, add the following code:

```dart
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
    FirebaseMessaging.onMessage.listen(_handleRemoteMessage);
    _tryConsumingIncomingCallFromTerminatedState();
    _observeDeepLinks();
  }
```

The last two methods called in `initState()` handle incoming calls and deep links respectively. Add these functions to the widget:

```dart
  Future<void> _observeDeepLinks() async {
    // The app was terminated.
    try {
      final initialUri = await getInitialUri();
      if (initialUri != null) {
        await _handleDeepLink(initialUri);
      }
    } catch (e) {
      debugPrint(e.toString());
    }

    // The app was in the background.
    if (!kIsWeb) {
      _subscription = uriLinkStream.listen((Uri? uri) {
        if (mounted && uri != null) {
          _handleDeepLink(uri);
        }
      });
    }
  }

  Future<void> _handleDeepLink(Uri uri) async {
    final callId = uri.pathSegments.last;

    if (userCredentials != null) {
      final user = YOUR_USER;
      final token = YOUR_USER_TOKEN;

      await StreamVideo.instance.connectUser(
        user,
        token.rawValue,
      );

      final call = StreamVideo.instance.makeCall(type: kCallType, id: callId);
      await call.getOrCreateCall();

      // Navigate to your call page
    }
  }

  void _tryConsumingIncomingCallFromTerminatedState() {
    if (_navigatorKey.currentContext == null) {
      // App is not running yet. Postpone consuming after app is in the foreground
      WidgetsBinding.instance.addPostFrameCallback((timeStamp) {
        _consumeIncomingCall();
      });
    } else {
      // no-op. If the app is already running we'll handle this in didChangeAppLifecycleState
    }
  }

  Future<void> _consumeIncomingCall() async {
    if (_navigatorKey.currentContext == null) {
      return;
    }
    final incomingCall = await StreamVideo.instance.consumeIncomingCall();
    if (incomingCall != null) {
      // Navigate to your call page
    }
  }
```

- Finally, add a `NavigatorKey` and add it to your `MaterialApp`/`CupertinoApp`/`WidgetsApp`:

```dart
  final GlobalKey<NavigatorState> _navigatorKey = GlobalKey<NavigatorState>();

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      navigatorKey: _navigatorKey,
      ...
    );
  }
```

### Integrating APNS for iOS

#### Step 1 - Get the iOS certificate for push notifications

- Generate push notification service key [here](https://developer.apple.com/account/resources/certificates/add). Make sure you select **Apple Push Notifications service SSL (Sandbox & Production).

- Convert the aps.cer file you created in the last step to a .p12 certificate file using keychain access. Make sure that you configure no password for the p12 file.

#### Step 2 - Upload the certificate and create a push provider

- Go the the dashboard of your video project at the [Stream website](https://getstream.io).

- Open the **Push Notifications** tab under **Video & Audio**.

- Select **New Configuration** and select **APN**.

- Add a name for your push provider in the **Name** field and add your previously generated P12 file with your additional Apple information.

- Click **Create** and your push provider should be ready.

#### Step 3 - Add dependencies

#### Step 4 - Add native code to the iOS project

### Registering a Device With Stream Backend

Once you configure a push provider and set it up on the Stream dashboard, a device that is supposed to receive push notifications needs to be registered on the Stream backend.

:::note
Device registration is carried out every time a user logs in and does not need to be implemented in your app.
:::

// TODO: Add device registration code

### Testing if Push Notifications are Setup Correctly

If you're not sure whether you've set up push notifications correctly, for example, you don't always receive them, or they donâ€™t work reliably, then you can follow these steps to make sure your configuration is correct and working:

1. Clone our repository for push testing: `git clone git@github.com:GetStream/chat-push-test.git`
2. `cd flutter`
3. In that folder run `flutter pub get`
4. Input your API key and secret in `lib/main.dart`
5. Change the bundle identifier/application ID and development team/user so you can run the app on your physical device.**Do not** run on an iOS simulator, as it will not work. Testing on an Android emulator is fine.
6. Add your `google-services.json/GoogleService-Info.plist`
7. Run the app
8. Accept push notification permission (iOS only)
9. Tap on `Device ID` and copy it
10. After configuring [stream-cli](https://github.com/GetStream/stream-cli), run the following command using your user ID:

```shell
stream chat:push:test -u <USER-ID>
```

You should get a test push notification ðŸ¥³
