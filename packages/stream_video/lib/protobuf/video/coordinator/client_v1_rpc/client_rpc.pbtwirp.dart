// Code generated by protoc-gen-flutter-twirp. DO NOT EDIT. video/coordinator/client_v1_rpc/client_rpc

import 'dart:convert';

import 'package:http/http.dart' as http;
import 'package:protobuf/protobuf.dart';
import 'package:tart/tart.dart' as twirp;
import 'client_rpc.pb.dart';
import 'package:stream_video/protobuf/google/protobuf/timestamp.pb.dart';
import 'package:stream_video/protobuf/video/coordinator/broadcast_v1/broadcast.pb.dart';
import 'package:stream_video/protobuf/video/coordinator/call_v1/call.pb.dart';
import 'package:stream_video/protobuf/video/coordinator/client_v1_rpc/envelopes.pb.dart';
import 'package:stream_video/protobuf/video/coordinator/edge_v1/edge.pb.dart';
import 'package:stream_video/protobuf/video/coordinator/push_v1/push.pb.dart';
import 'package:stream_video/protobuf/video/coordinator/stat_v1/stat.pb.dart';
import 'package:stream_video/protobuf/video/coordinator/user_v1/user.pb.dart';
import 'package:stream_video/protobuf/video/coordinator/utils_v1/utils.pb.dart';



abstract class ClientRPC {
  //  rpc GetCall(GetCallRequest) returns (GetCallResponse);
  Future<CreateCallResponse> createCall(twirp.Context ctx, CreateCallRequest req);
  
  Future<GetOrCreateCallResponse> getOrCreateCall(twirp.Context ctx, GetOrCreateCallRequest req);
  // JoinCall acts as GetOrCreateCall, but additionally returns list of datacenters to measure latency
  Future<JoinCallResponse> joinCall(twirp.Context ctx, JoinCallRequest req);
  // GetCallSFU returns SFU information that is required to establish a connection
  Future<GetCallEdgeServerResponse> getCallEdgeServer(twirp.Context ctx, GetCallEdgeServerRequest req);
  
  Future<UpdateCallResponse> updateCall(twirp.Context ctx, UpdateCallRequest req);
  // UpdateCallPermissions allows users to change permissions granted to members// this can be done in three ways:// 1. grant users a different role for this call (eg. make a host)// 2. grant users a permission on this call (eg. allow one user to screen-share)// 3. grant some permissions to all users (eg. allow participants to unmute themselves)
  Future<UpdateCallPermissionsResponse> updateCallPermissions(twirp.Context ctx, UpdateCallPermissionsRequest req);
  // EndCall sets the call as ended with the following side-effects:// the call itself is updated and ended_at set to current time// on-going call recording and broadcasting is stopped// all participants connected to the call are disconnected
  Future<EndCallResponse> endCall(twirp.Context ctx, EndCallRequest req);
  
  Future<QueryCallsResponse> queryCalls(twirp.Context ctx, QueryCallsRequest req);
  // QueryMembers gets a list of members that match your query criteria
  Future<QueryMembersResponse> queryMembers(twirp.Context ctx, QueryMembersRequest req);
  
  Future<CreateDeviceResponse> createDevice(twirp.Context ctx, CreateDeviceRequest req);
  
  Future<DeleteDeviceResponse> deleteDevice(twirp.Context ctx, DeleteDeviceRequest req);
  
  Future<QueryDevicesResponse> queryDevices(twirp.Context ctx, QueryDevicesRequest req);
  // starts broadcast to HLS and/or RTMP, replaces existing settings if broadcasting is already started
  Future<StartBroadcastResponse> startBroadcast(twirp.Context ctx, StartBroadcastRequest req);
  // stops broadcasting to HLS and/or RTMP
  Future<StopBroadcastResponse> stopBroadcast(twirp.Context ctx, StopBroadcastRequest req);
  
  Future<StartRecordingResponse> startRecording(twirp.Context ctx, StartRecordingRequest req);
  
  Future<StopRecordingResponse> stopRecording(twirp.Context ctx, StopRecordingRequest req);
  // Adds members to a call
  Future<UpsertCallMembersResponse> upsertCallMembers(twirp.Context ctx, UpsertCallMembersRequest req);
  // DeleteMembers deletes members from a room.
  Future<DeleteCallMembersResponse> deleteCallMembers(twirp.Context ctx, DeleteCallMembersRequest req);
  
  Future<SendEventResponse> sendEvent(twirp.Context ctx, SendEventRequest req);
  
  Future<SendCustomEventResponse> sendCustomEvent(twirp.Context ctx, SendCustomEventRequest req);
  
  Future<QueryUsersResponse> queryUsers(twirp.Context ctx, QueryUsersRequest req);
  
  Future<UpsertUsersResponse> upsertUsers(twirp.Context ctx, UpsertUsersRequest req);
  // endpoint for storing stats (perhaps we should move this to the SFU layer though)
  Future<ReportCallStatsResponse> reportCallStats(twirp.Context ctx, ReportCallStatsRequest req);
  // endpoint for storing stat-related events raised by the client
  Future<ReportCallStatEventResponse> reportCallStatEvent(twirp.Context ctx, ReportCallStatEventRequest req);
  // endpoint for reviewing/rating the quality of calls
  Future<ReviewCallResponse> reviewCall(twirp.Context ctx, ReviewCallRequest req);
  // endpoint for users to report issues with a call
  Future<ReportIssueResponse> reportIssue(twirp.Context ctx, ReportIssueRequest req);
}


class ClientRPCJSONClient implements ClientRPC {
  String baseUrl;
  String prefix;
  late twirp.ClientHooks hooks;
  late twirp.Interceptor interceptor;

  ClientRPCJSONClient(this.baseUrl, this.prefix, {twirp.ClientHooks? hooks, twirp.Interceptor? interceptor}) {
    if (!baseUrl.endsWith('/')) baseUrl += '/';
    if (!prefix.endsWith('/')) prefix += '/';
    if (prefix.startsWith('/')) prefix = prefix.substring(1);

    this.hooks = hooks ?? twirp.ClientHooks();
    this.interceptor = interceptor ?? twirp.chainInterceptor([]);
  }

  @override
  Future<CreateCallResponse> createCall(twirp.Context ctx, CreateCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'CreateCall');
    return interceptor((ctx, req) {
      return callCreateCall(ctx, req);
    })(ctx, req);
  }

  Future<CreateCallResponse> callCreateCall(twirp.Context ctx, CreateCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/CreateCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final CreateCallResponse res = CreateCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<GetOrCreateCallResponse> getOrCreateCall(twirp.Context ctx, GetOrCreateCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'GetOrCreateCall');
    return interceptor((ctx, req) {
      return callGetOrCreateCall(ctx, req);
    })(ctx, req);
  }

  Future<GetOrCreateCallResponse> callGetOrCreateCall(twirp.Context ctx, GetOrCreateCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/GetOrCreateCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final GetOrCreateCallResponse res = GetOrCreateCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<JoinCallResponse> joinCall(twirp.Context ctx, JoinCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'JoinCall');
    return interceptor((ctx, req) {
      return callJoinCall(ctx, req);
    })(ctx, req);
  }

  Future<JoinCallResponse> callJoinCall(twirp.Context ctx, JoinCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/JoinCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final JoinCallResponse res = JoinCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<GetCallEdgeServerResponse> getCallEdgeServer(twirp.Context ctx, GetCallEdgeServerRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'GetCallEdgeServer');
    return interceptor((ctx, req) {
      return callGetCallEdgeServer(ctx, req);
    })(ctx, req);
  }

  Future<GetCallEdgeServerResponse> callGetCallEdgeServer(twirp.Context ctx, GetCallEdgeServerRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/GetCallEdgeServer');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final GetCallEdgeServerResponse res = GetCallEdgeServerResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpdateCallResponse> updateCall(twirp.Context ctx, UpdateCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'UpdateCall');
    return interceptor((ctx, req) {
      return callUpdateCall(ctx, req);
    })(ctx, req);
  }

  Future<UpdateCallResponse> callUpdateCall(twirp.Context ctx, UpdateCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/UpdateCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final UpdateCallResponse res = UpdateCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpdateCallPermissionsResponse> updateCallPermissions(twirp.Context ctx, UpdateCallPermissionsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'UpdateCallPermissions');
    return interceptor((ctx, req) {
      return callUpdateCallPermissions(ctx, req);
    })(ctx, req);
  }

  Future<UpdateCallPermissionsResponse> callUpdateCallPermissions(twirp.Context ctx, UpdateCallPermissionsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/UpdateCallPermissions');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final UpdateCallPermissionsResponse res = UpdateCallPermissionsResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<EndCallResponse> endCall(twirp.Context ctx, EndCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'EndCall');
    return interceptor((ctx, req) {
      return callEndCall(ctx, req);
    })(ctx, req);
  }

  Future<EndCallResponse> callEndCall(twirp.Context ctx, EndCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/EndCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final EndCallResponse res = EndCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<QueryCallsResponse> queryCalls(twirp.Context ctx, QueryCallsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'QueryCalls');
    return interceptor((ctx, req) {
      return callQueryCalls(ctx, req);
    })(ctx, req);
  }

  Future<QueryCallsResponse> callQueryCalls(twirp.Context ctx, QueryCallsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/QueryCalls');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final QueryCallsResponse res = QueryCallsResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<QueryMembersResponse> queryMembers(twirp.Context ctx, QueryMembersRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'QueryMembers');
    return interceptor((ctx, req) {
      return callQueryMembers(ctx, req);
    })(ctx, req);
  }

  Future<QueryMembersResponse> callQueryMembers(twirp.Context ctx, QueryMembersRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/QueryMembers');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final QueryMembersResponse res = QueryMembersResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<CreateDeviceResponse> createDevice(twirp.Context ctx, CreateDeviceRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'CreateDevice');
    return interceptor((ctx, req) {
      return callCreateDevice(ctx, req);
    })(ctx, req);
  }

  Future<CreateDeviceResponse> callCreateDevice(twirp.Context ctx, CreateDeviceRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/CreateDevice');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final CreateDeviceResponse res = CreateDeviceResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<DeleteDeviceResponse> deleteDevice(twirp.Context ctx, DeleteDeviceRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'DeleteDevice');
    return interceptor((ctx, req) {
      return callDeleteDevice(ctx, req);
    })(ctx, req);
  }

  Future<DeleteDeviceResponse> callDeleteDevice(twirp.Context ctx, DeleteDeviceRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/DeleteDevice');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final DeleteDeviceResponse res = DeleteDeviceResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<QueryDevicesResponse> queryDevices(twirp.Context ctx, QueryDevicesRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'QueryDevices');
    return interceptor((ctx, req) {
      return callQueryDevices(ctx, req);
    })(ctx, req);
  }

  Future<QueryDevicesResponse> callQueryDevices(twirp.Context ctx, QueryDevicesRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/QueryDevices');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final QueryDevicesResponse res = QueryDevicesResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StartBroadcastResponse> startBroadcast(twirp.Context ctx, StartBroadcastRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'StartBroadcast');
    return interceptor((ctx, req) {
      return callStartBroadcast(ctx, req);
    })(ctx, req);
  }

  Future<StartBroadcastResponse> callStartBroadcast(twirp.Context ctx, StartBroadcastRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/StartBroadcast');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final StartBroadcastResponse res = StartBroadcastResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StopBroadcastResponse> stopBroadcast(twirp.Context ctx, StopBroadcastRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'StopBroadcast');
    return interceptor((ctx, req) {
      return callStopBroadcast(ctx, req);
    })(ctx, req);
  }

  Future<StopBroadcastResponse> callStopBroadcast(twirp.Context ctx, StopBroadcastRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/StopBroadcast');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final StopBroadcastResponse res = StopBroadcastResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StartRecordingResponse> startRecording(twirp.Context ctx, StartRecordingRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'StartRecording');
    return interceptor((ctx, req) {
      return callStartRecording(ctx, req);
    })(ctx, req);
  }

  Future<StartRecordingResponse> callStartRecording(twirp.Context ctx, StartRecordingRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/StartRecording');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final StartRecordingResponse res = StartRecordingResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StopRecordingResponse> stopRecording(twirp.Context ctx, StopRecordingRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'StopRecording');
    return interceptor((ctx, req) {
      return callStopRecording(ctx, req);
    })(ctx, req);
  }

  Future<StopRecordingResponse> callStopRecording(twirp.Context ctx, StopRecordingRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/StopRecording');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final StopRecordingResponse res = StopRecordingResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpsertCallMembersResponse> upsertCallMembers(twirp.Context ctx, UpsertCallMembersRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'UpsertCallMembers');
    return interceptor((ctx, req) {
      return callUpsertCallMembers(ctx, req);
    })(ctx, req);
  }

  Future<UpsertCallMembersResponse> callUpsertCallMembers(twirp.Context ctx, UpsertCallMembersRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/UpsertCallMembers');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final UpsertCallMembersResponse res = UpsertCallMembersResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<DeleteCallMembersResponse> deleteCallMembers(twirp.Context ctx, DeleteCallMembersRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'DeleteCallMembers');
    return interceptor((ctx, req) {
      return callDeleteCallMembers(ctx, req);
    })(ctx, req);
  }

  Future<DeleteCallMembersResponse> callDeleteCallMembers(twirp.Context ctx, DeleteCallMembersRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/DeleteCallMembers');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final DeleteCallMembersResponse res = DeleteCallMembersResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SendEventResponse> sendEvent(twirp.Context ctx, SendEventRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'SendEvent');
    return interceptor((ctx, req) {
      return callSendEvent(ctx, req);
    })(ctx, req);
  }

  Future<SendEventResponse> callSendEvent(twirp.Context ctx, SendEventRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/SendEvent');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final SendEventResponse res = SendEventResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SendCustomEventResponse> sendCustomEvent(twirp.Context ctx, SendCustomEventRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'SendCustomEvent');
    return interceptor((ctx, req) {
      return callSendCustomEvent(ctx, req);
    })(ctx, req);
  }

  Future<SendCustomEventResponse> callSendCustomEvent(twirp.Context ctx, SendCustomEventRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/SendCustomEvent');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final SendCustomEventResponse res = SendCustomEventResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<QueryUsersResponse> queryUsers(twirp.Context ctx, QueryUsersRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'QueryUsers');
    return interceptor((ctx, req) {
      return callQueryUsers(ctx, req);
    })(ctx, req);
  }

  Future<QueryUsersResponse> callQueryUsers(twirp.Context ctx, QueryUsersRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/QueryUsers');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final QueryUsersResponse res = QueryUsersResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpsertUsersResponse> upsertUsers(twirp.Context ctx, UpsertUsersRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'UpsertUsers');
    return interceptor((ctx, req) {
      return callUpsertUsers(ctx, req);
    })(ctx, req);
  }

  Future<UpsertUsersResponse> callUpsertUsers(twirp.Context ctx, UpsertUsersRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/UpsertUsers');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final UpsertUsersResponse res = UpsertUsersResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ReportCallStatsResponse> reportCallStats(twirp.Context ctx, ReportCallStatsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'ReportCallStats');
    return interceptor((ctx, req) {
      return callReportCallStats(ctx, req);
    })(ctx, req);
  }

  Future<ReportCallStatsResponse> callReportCallStats(twirp.Context ctx, ReportCallStatsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/ReportCallStats');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final ReportCallStatsResponse res = ReportCallStatsResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ReportCallStatEventResponse> reportCallStatEvent(twirp.Context ctx, ReportCallStatEventRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'ReportCallStatEvent');
    return interceptor((ctx, req) {
      return callReportCallStatEvent(ctx, req);
    })(ctx, req);
  }

  Future<ReportCallStatEventResponse> callReportCallStatEvent(twirp.Context ctx, ReportCallStatEventRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/ReportCallStatEvent');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final ReportCallStatEventResponse res = ReportCallStatEventResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ReviewCallResponse> reviewCall(twirp.Context ctx, ReviewCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'ReviewCall');
    return interceptor((ctx, req) {
      return callReviewCall(ctx, req);
    })(ctx, req);
  }

  Future<ReviewCallResponse> callReviewCall(twirp.Context ctx, ReviewCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/ReviewCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final ReviewCallResponse res = ReviewCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ReportIssueResponse> reportIssue(twirp.Context ctx, ReportIssueRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'ReportIssue');
    return interceptor((ctx, req) {
      return callReportIssue(ctx, req);
    })(ctx, req);
  }

  Future<ReportIssueResponse> callReportIssue(twirp.Context ctx, ReportIssueRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/ReportIssue');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final ReportIssueResponse res = ReportIssueResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }
}


class ClientRPCProtobufClient implements ClientRPC {
  String baseUrl;
  String prefix;
  late twirp.ClientHooks hooks;
  late twirp.Interceptor interceptor;

  ClientRPCProtobufClient(this.baseUrl, this.prefix, {twirp.ClientHooks? hooks, twirp.Interceptor? interceptor}) {
    if (!baseUrl.endsWith('/')) baseUrl += '/';
    if (!prefix.endsWith('/')) prefix += '/';
    if (prefix.startsWith('/')) prefix = prefix.substring(1);

    this.hooks = hooks ?? twirp.ClientHooks();
    this.interceptor = interceptor ?? twirp.chainInterceptor([]);
  }

  @override
  Future<CreateCallResponse> createCall(twirp.Context ctx, CreateCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'CreateCall');
    return interceptor((ctx, req) {
      return callCreateCall(ctx, req);
    })(ctx, req);
  }

  Future<CreateCallResponse> callCreateCall(twirp.Context ctx, CreateCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/CreateCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final CreateCallResponse res = CreateCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<GetOrCreateCallResponse> getOrCreateCall(twirp.Context ctx, GetOrCreateCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'GetOrCreateCall');
    return interceptor((ctx, req) {
      return callGetOrCreateCall(ctx, req);
    })(ctx, req);
  }

  Future<GetOrCreateCallResponse> callGetOrCreateCall(twirp.Context ctx, GetOrCreateCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/GetOrCreateCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final GetOrCreateCallResponse res = GetOrCreateCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<JoinCallResponse> joinCall(twirp.Context ctx, JoinCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'JoinCall');
    return interceptor((ctx, req) {
      return callJoinCall(ctx, req);
    })(ctx, req);
  }

  Future<JoinCallResponse> callJoinCall(twirp.Context ctx, JoinCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/JoinCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final JoinCallResponse res = JoinCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<GetCallEdgeServerResponse> getCallEdgeServer(twirp.Context ctx, GetCallEdgeServerRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'GetCallEdgeServer');
    return interceptor((ctx, req) {
      return callGetCallEdgeServer(ctx, req);
    })(ctx, req);
  }

  Future<GetCallEdgeServerResponse> callGetCallEdgeServer(twirp.Context ctx, GetCallEdgeServerRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/GetCallEdgeServer');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final GetCallEdgeServerResponse res = GetCallEdgeServerResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpdateCallResponse> updateCall(twirp.Context ctx, UpdateCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'UpdateCall');
    return interceptor((ctx, req) {
      return callUpdateCall(ctx, req);
    })(ctx, req);
  }

  Future<UpdateCallResponse> callUpdateCall(twirp.Context ctx, UpdateCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/UpdateCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final UpdateCallResponse res = UpdateCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpdateCallPermissionsResponse> updateCallPermissions(twirp.Context ctx, UpdateCallPermissionsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'UpdateCallPermissions');
    return interceptor((ctx, req) {
      return callUpdateCallPermissions(ctx, req);
    })(ctx, req);
  }

  Future<UpdateCallPermissionsResponse> callUpdateCallPermissions(twirp.Context ctx, UpdateCallPermissionsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/UpdateCallPermissions');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final UpdateCallPermissionsResponse res = UpdateCallPermissionsResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<EndCallResponse> endCall(twirp.Context ctx, EndCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'EndCall');
    return interceptor((ctx, req) {
      return callEndCall(ctx, req);
    })(ctx, req);
  }

  Future<EndCallResponse> callEndCall(twirp.Context ctx, EndCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/EndCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final EndCallResponse res = EndCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<QueryCallsResponse> queryCalls(twirp.Context ctx, QueryCallsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'QueryCalls');
    return interceptor((ctx, req) {
      return callQueryCalls(ctx, req);
    })(ctx, req);
  }

  Future<QueryCallsResponse> callQueryCalls(twirp.Context ctx, QueryCallsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/QueryCalls');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final QueryCallsResponse res = QueryCallsResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<QueryMembersResponse> queryMembers(twirp.Context ctx, QueryMembersRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'QueryMembers');
    return interceptor((ctx, req) {
      return callQueryMembers(ctx, req);
    })(ctx, req);
  }

  Future<QueryMembersResponse> callQueryMembers(twirp.Context ctx, QueryMembersRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/QueryMembers');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final QueryMembersResponse res = QueryMembersResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<CreateDeviceResponse> createDevice(twirp.Context ctx, CreateDeviceRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'CreateDevice');
    return interceptor((ctx, req) {
      return callCreateDevice(ctx, req);
    })(ctx, req);
  }

  Future<CreateDeviceResponse> callCreateDevice(twirp.Context ctx, CreateDeviceRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/CreateDevice');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final CreateDeviceResponse res = CreateDeviceResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<DeleteDeviceResponse> deleteDevice(twirp.Context ctx, DeleteDeviceRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'DeleteDevice');
    return interceptor((ctx, req) {
      return callDeleteDevice(ctx, req);
    })(ctx, req);
  }

  Future<DeleteDeviceResponse> callDeleteDevice(twirp.Context ctx, DeleteDeviceRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/DeleteDevice');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final DeleteDeviceResponse res = DeleteDeviceResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<QueryDevicesResponse> queryDevices(twirp.Context ctx, QueryDevicesRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'QueryDevices');
    return interceptor((ctx, req) {
      return callQueryDevices(ctx, req);
    })(ctx, req);
  }

  Future<QueryDevicesResponse> callQueryDevices(twirp.Context ctx, QueryDevicesRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/QueryDevices');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final QueryDevicesResponse res = QueryDevicesResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StartBroadcastResponse> startBroadcast(twirp.Context ctx, StartBroadcastRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'StartBroadcast');
    return interceptor((ctx, req) {
      return callStartBroadcast(ctx, req);
    })(ctx, req);
  }

  Future<StartBroadcastResponse> callStartBroadcast(twirp.Context ctx, StartBroadcastRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/StartBroadcast');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final StartBroadcastResponse res = StartBroadcastResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StopBroadcastResponse> stopBroadcast(twirp.Context ctx, StopBroadcastRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'StopBroadcast');
    return interceptor((ctx, req) {
      return callStopBroadcast(ctx, req);
    })(ctx, req);
  }

  Future<StopBroadcastResponse> callStopBroadcast(twirp.Context ctx, StopBroadcastRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/StopBroadcast');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final StopBroadcastResponse res = StopBroadcastResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StartRecordingResponse> startRecording(twirp.Context ctx, StartRecordingRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'StartRecording');
    return interceptor((ctx, req) {
      return callStartRecording(ctx, req);
    })(ctx, req);
  }

  Future<StartRecordingResponse> callStartRecording(twirp.Context ctx, StartRecordingRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/StartRecording');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final StartRecordingResponse res = StartRecordingResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StopRecordingResponse> stopRecording(twirp.Context ctx, StopRecordingRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'StopRecording');
    return interceptor((ctx, req) {
      return callStopRecording(ctx, req);
    })(ctx, req);
  }

  Future<StopRecordingResponse> callStopRecording(twirp.Context ctx, StopRecordingRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/StopRecording');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final StopRecordingResponse res = StopRecordingResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpsertCallMembersResponse> upsertCallMembers(twirp.Context ctx, UpsertCallMembersRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'UpsertCallMembers');
    return interceptor((ctx, req) {
      return callUpsertCallMembers(ctx, req);
    })(ctx, req);
  }

  Future<UpsertCallMembersResponse> callUpsertCallMembers(twirp.Context ctx, UpsertCallMembersRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/UpsertCallMembers');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final UpsertCallMembersResponse res = UpsertCallMembersResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<DeleteCallMembersResponse> deleteCallMembers(twirp.Context ctx, DeleteCallMembersRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'DeleteCallMembers');
    return interceptor((ctx, req) {
      return callDeleteCallMembers(ctx, req);
    })(ctx, req);
  }

  Future<DeleteCallMembersResponse> callDeleteCallMembers(twirp.Context ctx, DeleteCallMembersRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/DeleteCallMembers');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final DeleteCallMembersResponse res = DeleteCallMembersResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SendEventResponse> sendEvent(twirp.Context ctx, SendEventRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'SendEvent');
    return interceptor((ctx, req) {
      return callSendEvent(ctx, req);
    })(ctx, req);
  }

  Future<SendEventResponse> callSendEvent(twirp.Context ctx, SendEventRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/SendEvent');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final SendEventResponse res = SendEventResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SendCustomEventResponse> sendCustomEvent(twirp.Context ctx, SendCustomEventRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'SendCustomEvent');
    return interceptor((ctx, req) {
      return callSendCustomEvent(ctx, req);
    })(ctx, req);
  }

  Future<SendCustomEventResponse> callSendCustomEvent(twirp.Context ctx, SendCustomEventRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/SendCustomEvent');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final SendCustomEventResponse res = SendCustomEventResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<QueryUsersResponse> queryUsers(twirp.Context ctx, QueryUsersRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'QueryUsers');
    return interceptor((ctx, req) {
      return callQueryUsers(ctx, req);
    })(ctx, req);
  }

  Future<QueryUsersResponse> callQueryUsers(twirp.Context ctx, QueryUsersRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/QueryUsers');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final QueryUsersResponse res = QueryUsersResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpsertUsersResponse> upsertUsers(twirp.Context ctx, UpsertUsersRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'UpsertUsers');
    return interceptor((ctx, req) {
      return callUpsertUsers(ctx, req);
    })(ctx, req);
  }

  Future<UpsertUsersResponse> callUpsertUsers(twirp.Context ctx, UpsertUsersRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/UpsertUsers');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final UpsertUsersResponse res = UpsertUsersResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ReportCallStatsResponse> reportCallStats(twirp.Context ctx, ReportCallStatsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'ReportCallStats');
    return interceptor((ctx, req) {
      return callReportCallStats(ctx, req);
    })(ctx, req);
  }

  Future<ReportCallStatsResponse> callReportCallStats(twirp.Context ctx, ReportCallStatsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/ReportCallStats');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final ReportCallStatsResponse res = ReportCallStatsResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ReportCallStatEventResponse> reportCallStatEvent(twirp.Context ctx, ReportCallStatEventRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'ReportCallStatEvent');
    return interceptor((ctx, req) {
      return callReportCallStatEvent(ctx, req);
    })(ctx, req);
  }

  Future<ReportCallStatEventResponse> callReportCallStatEvent(twirp.Context ctx, ReportCallStatEventRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/ReportCallStatEvent');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final ReportCallStatEventResponse res = ReportCallStatEventResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ReviewCallResponse> reviewCall(twirp.Context ctx, ReviewCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'ReviewCall');
    return interceptor((ctx, req) {
      return callReviewCall(ctx, req);
    })(ctx, req);
  }

  Future<ReviewCallResponse> callReviewCall(twirp.Context ctx, ReviewCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/ReviewCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final ReviewCallResponse res = ReviewCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ReportIssueResponse> reportIssue(twirp.Context ctx, ReportIssueRequest req) async {
    ctx = twirp.withPackageName(ctx, 'client_v1_rpc');
    ctx = twirp.withServiceName(ctx, 'ClientRPC');
    ctx = twirp.withMethodName(ctx, 'ReportIssue');
    return interceptor((ctx, req) {
      return callReportIssue(ctx, req);
    })(ctx, req);
  }

  Future<ReportIssueResponse> callReportIssue(twirp.Context ctx, ReportIssueRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.coordinator.client_v1_rpc.ClientRPC/ReportIssue');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final ReportIssueResponse res = ReportIssueResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }
}

Future<List<int>> doProtobufRequest(twirp.Context ctx, Uri url,
    twirp.ClientHooks hooks, GeneratedMessage msgReq) async {
  // setup http client
  final httpClient = http.Client();

  try {
    // create http request
    final req = createRequest(url, ctx, 'application/protobuf');

    // add request data to body
    req.bodyBytes = msgReq.writeToBuffer();

    // call onRequestPrepared hook for user to modify request
    ctx = hooks.onRequestPrepared(ctx, req);

    // send data
    final res = await httpClient.send(req);

    // if success, parse and return response
    if (res.statusCode == 200) {
      List<int> data = <int>[];
      await res.stream.listen((value) {
        data.addAll(value);
      }).asFuture();
      hooks.onResponseReceived(ctx);
      return Future.value(data);
    }

    // we received a twirp related error
    throw twirp.TwirpError.fromJson(
        json.decode(await res.stream.transform(utf8.decoder).join()), ctx);
  } on twirp.TwirpError catch (twirpErr) {
    hooks.onError(ctx, twirpErr);
    rethrow;
  } catch (e) {
    // catch http connection error or from onRequestPrepared
    final twirpErr = twirp.TwirpError.fromConnectionError(e.toString(), ctx);
    hooks.onError(ctx, twirpErr);
    throw twirpErr;
  } finally {
    httpClient.close();
  }
}

Future<String> doJSONRequest(twirp.Context ctx, Uri url,
    twirp.ClientHooks hooks, GeneratedMessage msgReq) async {
  // setup http client
  final httpClient = http.Client();

  try {
    // create http request
    final req = createRequest(url, ctx, 'application/json');

    // add request data to body
    req.body = json.encode(msgReq.toProto3Json());

    // call onRequestPrepared hook for user to modify request
    ctx = hooks.onRequestPrepared(ctx, req);

    // send data
    final res = await httpClient.send(req);

    // if success, parse and return response
    if (res.statusCode == 200) {
      final data = await res.stream.transform(utf8.decoder).join().then((data) {
        hooks.onResponseReceived(ctx);
        return data;
      });
      return Future.value(data);
    }

    // we received a twirp related error
    throw twirp.TwirpError.fromJson(
        json.decode(await res.stream.transform(utf8.decoder).join()), ctx);
  } on twirp.TwirpError catch (twirpErr) {
    hooks.onError(ctx, twirpErr);
    rethrow;
  } catch (e) {
    // catch http connection error or from onRequestPrepared
    final twirpErr = twirp.TwirpError.fromConnectionError(e.toString(), ctx);
    hooks.onError(ctx, twirpErr);
    throw twirpErr;
  } finally {
    httpClient.close();
  }
}

http.Request createRequest(
    Uri url, twirp.Context ctx, String applicationHeader) {
  // setup request
  final req = http.Request("POST", url);

  // add headers from context
  final headersFromCtx = twirp.retrieveHttpRequestHeaders(ctx) ?? {};
  req.headers.addAll(headersFromCtx);

  // add required headers
  req.headers['Accept'] = applicationHeader;
  req.headers['Content-Type'] = applicationHeader;

  return req;
}
