// Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.

// ignore_for_file: use_string_in_part_of_directives
// ignore_for_file: unnecessary_raw_strings

part of openapi.api;

@immutable
class PushPreferences {
  const PushPreferences({
    this.callLevel,
    this.chatLevel,
    this.disabledUntil,
  });

  final String? callLevel;

  final String? chatLevel;

  final DateTime? disabledUntil;

  Map<String, dynamic> toJson() {
    return {
      'call_level': callLevel,
      'chat_level': chatLevel,
      'disabled_until': disabledUntil,
    };
  }

  static PushPreferences? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      return PushPreferences(
        callLevel: mapValueOfType<String?>(json, r'call_level', null),
        chatLevel: mapValueOfType<String?>(json, r'chat_level', null),
        disabledUntil: mapValueOfType<DateTime?>(json, r'disabled_until', null),
      );
    }
    return null;
  }

  static List<PushPreferences> listFromJson(
    dynamic json, {
    bool growable = false,
  }) {
    final result = <PushPreferences>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = PushPreferences.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  @override
  String toString() {
    return 'PushPreferences('
        'callLevel: $callLevel, '
        'chatLevel: $chatLevel, '
        'disabledUntil: $disabledUntil, '
        ')';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is PushPreferences &&
        other.callLevel == callLevel &&
        other.chatLevel == chatLevel &&
        other.disabledUntil == disabledUntil;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      callLevel,
      chatLevel,
      disabledUntil,
    ]);
  }
}
