// Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.

// ignore_for_file: use_string_in_part_of_directives
// ignore_for_file: unnecessary_raw_strings

part of openapi.api;

@immutable
class CallSessionResponse {
  const CallSessionResponse({
    required this.acceptedBy,
    required this.anonymousParticipantCount,
    this.endedAt,
    required this.id,
    this.liveEndedAt,
    this.liveStartedAt,
    required this.missedBy,
    required this.participants,
    required this.participantsCountByRole,
    required this.rejectedBy,
    this.startedAt,
    this.timerEndsAt,
  });

  final Map<String, DateTime> acceptedBy;

  final int anonymousParticipantCount;

  final DateTime? endedAt;

  final String id;

  final DateTime? liveEndedAt;

  final DateTime? liveStartedAt;

  final Map<String, DateTime> missedBy;

  final List<CallParticipantResponse> participants;

  final Map<String, int> participantsCountByRole;

  final Map<String, DateTime> rejectedBy;

  final DateTime? startedAt;

  final DateTime? timerEndsAt;

  Map<String, dynamic> toJson() {
    return {
      'accepted_by': acceptedBy,
      'anonymous_participant_count': anonymousParticipantCount,
      'ended_at': endedAt,
      'id': id,
      'live_ended_at': liveEndedAt,
      'live_started_at': liveStartedAt,
      'missed_by': missedBy,
      'participants': participants,
      'participants_count_by_role': participantsCountByRole,
      'rejected_by': rejectedBy,
      'started_at': startedAt,
      'timer_ends_at': timerEndsAt,
    };
  }

  static CallSessionResponse? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      return CallSessionResponse(
        acceptedBy: mapCastOfType<String, DateTime>(json, r'accepted_by')!,
        anonymousParticipantCount:
            mapValueOfType<int>(json, r'anonymous_participant_count')!,
        endedAt: mapValueOfType<DateTime>(json, r'ended_at', null),
        id: mapValueOfType<String>(json, r'id')!,
        liveEndedAt: mapValueOfType<DateTime>(json, r'live_ended_at', null),
        liveStartedAt: mapValueOfType<DateTime>(json, r'live_started_at', null),
        missedBy: mapCastOfType<String, DateTime>(json, r'missed_by')!,
        participants:
            CallParticipantResponse.listFromJson(json[r'participants'])!,
        participantsCountByRole:
            mapCastOfType<String, int>(json, r'participants_count_by_role')!,
        rejectedBy: mapCastOfType<String, DateTime>(json, r'rejected_by')!,
        startedAt: mapValueOfType<DateTime>(json, r'started_at', null),
        timerEndsAt: mapValueOfType<DateTime>(json, r'timer_ends_at', null),
      );
    }
    return null;
  }

  static List<CallSessionResponse> listFromJson(
    dynamic json, {
    bool growable = false,
  }) {
    final result = <CallSessionResponse>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = CallSessionResponse.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  @override
  String toString() {
    return 'CallSessionResponse('
        'acceptedBy: $acceptedBy, '
        'anonymousParticipantCount: $anonymousParticipantCount, '
        'endedAt: $endedAt, '
        'id: $id, '
        'liveEndedAt: $liveEndedAt, '
        'liveStartedAt: $liveStartedAt, '
        'missedBy: $missedBy, '
        'participants: $participants, '
        'participantsCountByRole: $participantsCountByRole, '
        'rejectedBy: $rejectedBy, '
        'startedAt: $startedAt, '
        'timerEndsAt: $timerEndsAt, '
        ')';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is CallSessionResponse &&
        other.acceptedBy == acceptedBy &&
        other.anonymousParticipantCount == anonymousParticipantCount &&
        other.endedAt == endedAt &&
        other.id == id &&
        other.liveEndedAt == liveEndedAt &&
        other.liveStartedAt == liveStartedAt &&
        other.missedBy == missedBy &&
        other.participants == participants &&
        other.participantsCountByRole == participantsCountByRole &&
        other.rejectedBy == rejectedBy &&
        other.startedAt == startedAt &&
        other.timerEndsAt == timerEndsAt;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      acceptedBy,
      anonymousParticipantCount,
      endedAt,
      id,
      liveEndedAt,
      liveStartedAt,
      missedBy,
      participants,
      participantsCountByRole,
      rejectedBy,
      startedAt,
      timerEndsAt,
    ]);
  }
}
