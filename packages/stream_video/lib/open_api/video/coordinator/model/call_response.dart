// Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.

// ignore_for_file: use_string_in_part_of_directives
// ignore_for_file: unnecessary_raw_strings

part of openapi.api;

@immutable
class CallResponse {
  const CallResponse({
    required this.backstage,
    required this.blockedUserIds,
    required this.captioning,
    this.channelCid,
    required this.cid,
    required this.createdAt,
    required this.createdBy,
    required this.currentSessionId,
    required this.custom,
    required this.egress,
    this.endedAt,
    required this.id,
    required this.ingress,
    this.joinAheadTimeSeconds,
    required this.recording,
    this.session,
    required this.settings,
    this.startsAt,
    this.team,
    this.thumbnails,
    required this.transcribing,
    required this.type,
    required this.updatedAt,
  });

  final bool backstage;

  final List<String> blockedUserIds;

  final bool captioning;

  final String? channelCid;

  final String cid;

  final DateTime createdAt;

  final UserResponse createdBy;

  final String currentSessionId;

  final Map<String, Object> custom;

  final EgressResponse egress;

  final DateTime? endedAt;

  final String id;

  final CallIngressResponse ingress;

  final int? joinAheadTimeSeconds;

  final bool recording;

  final CallSessionResponse? session;

  final CallSettingsResponse settings;

  final DateTime? startsAt;

  final String? team;

  final ThumbnailResponse? thumbnails;

  final bool transcribing;

  final String type;

  final DateTime updatedAt;

  Map<String, dynamic> toJson() {
    return {
      'backstage': backstage,
      'blocked_user_ids': blockedUserIds,
      'captioning': captioning,
      'channel_cid': channelCid,
      'cid': cid,
      'created_at': createdAt,
      'created_by': createdBy,
      'current_session_id': currentSessionId,
      'custom': custom,
      'egress': egress,
      'ended_at': endedAt,
      'id': id,
      'ingress': ingress,
      'join_ahead_time_seconds': joinAheadTimeSeconds,
      'recording': recording,
      'session': session,
      'settings': settings,
      'starts_at': startsAt,
      'team': team,
      'thumbnails': thumbnails,
      'transcribing': transcribing,
      'type': type,
      'updated_at': updatedAt,
    };
  }

  static CallResponse? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      return CallResponse(
        backstage: mapValueOfType<bool>(json, r'backstage')!,
        blockedUserIds: json[r'blocked_user_ids'] is Iterable
            ? (json[r'blocked_user_ids'] as Iterable)
                .cast<String>()
                .toList(growable: false)
            : const []!,
        captioning: mapValueOfType<bool>(json, r'captioning')!,
        channelCid: mapValueOfType<String?>(json, r'channel_cid', null),
        cid: mapValueOfType<String>(json, r'cid')!,
        createdAt: mapValueOfType<DateTime>(json, r'created_at')!,
        createdBy: UserResponse.fromJson(json[r'created_by'])!,
        currentSessionId: mapValueOfType<String>(json, r'current_session_id')!,
        custom: mapCastOfType<String, Object>(json, r'custom')!,
        egress: EgressResponse.fromJson(json[r'egress'])!,
        endedAt: mapValueOfType<DateTime?>(json, r'ended_at', null),
        id: mapValueOfType<String>(json, r'id')!,
        ingress: CallIngressResponse.fromJson(json[r'ingress'])!,
        joinAheadTimeSeconds:
            mapValueOfType<int?>(json, r'join_ahead_time_seconds', null),
        recording: mapValueOfType<bool>(json, r'recording')!,
        session: CallSessionResponse?.fromJson(json[r'session'] ?? null),
        settings: CallSettingsResponse.fromJson(json[r'settings'])!,
        startsAt: mapValueOfType<DateTime?>(json, r'starts_at', null),
        team: mapValueOfType<String?>(json, r'team', null),
        thumbnails: ThumbnailResponse?.fromJson(json[r'thumbnails'] ?? null),
        transcribing: mapValueOfType<bool>(json, r'transcribing')!,
        type: mapValueOfType<String>(json, r'type')!,
        updatedAt: mapValueOfType<DateTime>(json, r'updated_at')!,
      );
    }
    return null;
  }

  static List<CallResponse> listFromJson(
    dynamic json, {
    bool growable = false,
  }) {
    final result = <CallResponse>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = CallResponse.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  @override
  String toString() {
    return 'CallResponse('
        'backstage: $backstage, '
        'blockedUserIds: $blockedUserIds, '
        'captioning: $captioning, '
        'channelCid: $channelCid, '
        'cid: $cid, '
        'createdAt: $createdAt, '
        'createdBy: $createdBy, '
        'currentSessionId: $currentSessionId, '
        'custom: $custom, '
        'egress: $egress, '
        'endedAt: $endedAt, '
        'id: $id, '
        'ingress: $ingress, '
        'joinAheadTimeSeconds: $joinAheadTimeSeconds, '
        'recording: $recording, '
        'session: $session, '
        'settings: $settings, '
        'startsAt: $startsAt, '
        'team: $team, '
        'thumbnails: $thumbnails, '
        'transcribing: $transcribing, '
        'type: $type, '
        'updatedAt: $updatedAt, '
        ')';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is CallResponse &&
        other.backstage == backstage &&
        other.blockedUserIds == blockedUserIds &&
        other.captioning == captioning &&
        other.channelCid == channelCid &&
        other.cid == cid &&
        other.createdAt == createdAt &&
        other.createdBy == createdBy &&
        other.currentSessionId == currentSessionId &&
        other.custom == custom &&
        other.egress == egress &&
        other.endedAt == endedAt &&
        other.id == id &&
        other.ingress == ingress &&
        other.joinAheadTimeSeconds == joinAheadTimeSeconds &&
        other.recording == recording &&
        other.session == session &&
        other.settings == settings &&
        other.startsAt == startsAt &&
        other.team == team &&
        other.thumbnails == thumbnails &&
        other.transcribing == transcribing &&
        other.type == type &&
        other.updatedAt == updatedAt;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      backstage,
      blockedUserIds,
      captioning,
      channelCid,
      cid,
      createdAt,
      createdBy,
      currentSessionId,
      custom,
      egress,
      endedAt,
      id,
      ingress,
      joinAheadTimeSeconds,
      recording,
      session,
      settings,
      startsAt,
      team,
      thumbnails,
      transcribing,
      type,
      updatedAt,
    ]);
  }
}
